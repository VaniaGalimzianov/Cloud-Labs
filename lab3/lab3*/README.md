# Лабораторная работа №3*

## Задание
Сделать красиво работу с секретами. Например, поднять Hashicorp Vault (или другую секретохранилку) и сделать так, чтобы ci/cd пайплайн (или любой другой ваш сервис) ходил туда, брал секрет, использовал его не светя в логах. В Readme аргументировать почему ваш способ красивый, а также описать, почему хранение секретов в CI/CD переменных репозитория не является хорошей практикой.

## Выполнение работы
### Установка и настройка Hashicorp Vault
В качестве хранилища секретов при выполнении лабораторной работы был выбран Hashicorp Vault, запущенный локально в окне терминала.
На начальном этапе был установлен Vault. Процесс установки приведен на изображениях ниже:

<img width="565" alt="Screenshot 2024-12-12 at 21 57 45" src="https://github.com/user-attachments/assets/ab686f3f-54a0-4cc7-91bf-983e36efd8b7" />
<img width="568" alt="Screenshot 2024-12-12 at 21 58 39" src="https://github.com/user-attachments/assets/9d01b667-7696-492a-8c5c-93766e2f4914" />

Затем был проведен запуск хранилища на локальном порту 8200. Результат запуска приведен ниже:

<img width="530" alt="Screenshot 2024-12-12 at 22 06 40" src="https://github.com/user-attachments/assets/bf308670-4bdb-4c6a-a6fe-dce27485a6e0" />

### Помещение секретов в хранилище
На следующем этапе в другом окне терминала был указан адрес `VAULT_ADDR` сервера Vault с помощью команды `export VAULT_ADDR='http://127.0.0.1:8200'`. Далее в хранилище были помещены секреты: адрес, пароль доступа, имя пользователя и базы данных. Результат добавления и проверка внесения секретов изображены на рисунках ниже:

<img width="568" alt="Screenshot 2024-12-12 at 22 37 33" src="https://github.com/user-attachments/assets/bc73eb04-1b69-4de1-866d-62f293d3f7e6" />
<img width="531" alt="Screenshot 2024-12-12 at 22 37 51" src="https://github.com/user-attachments/assets/8742df43-4ccb-4258-9a1d-4b151c1066ad" />

### Подключение OIDC
Для улучшения процесса получения секретов была добавлена аутентификация при помощи OIDC. С помощью `vault auth enable oidc` было проведено включение аутентификации данным способом, а затем настроена интеграция с Github Actions. Vault работает напрямую с OIDC токенами, которые предоставляет GitHub Actions, поэтому конфигурация выполняется с помощью следующей команды:
```
vault write auth/oidc/config
  oidc_discovery_url="https://token.actions.githubusercontent.com" // адрес получения токенов
  default_role="github"                                            // роль по умолчанию
```

Кроме того, необходимо было определить политику доступа к секретам. Для этого в файле `github-policy.hcl` были определены какие из секретов могут быть прочитаны. Код данного файла изображен ниже:

<img width="282" alt="Screenshot 2024-12-12 at 22 17 08" src="https://github.com/user-attachments/assets/70835fe4-7b93-4d58-b65e-f1f82e17f365" />

Затем с помощью команды `vault policy write github-policy github-policy.hcl` созданная политика была загружена в Vault. Далее для аутентификации была записана соответствующая роль. Результат создания роли приведен на рисунке ниже:

<img width="548" alt="Screenshot 2024-12-12 at 22 19 40" src="https://github.com/user-attachments/assets/8a6bf228-4dbc-41fe-88a7-29ada0182045" />

### Создание туннеля для доступа к локальному Vault
Для предоставления публичного доступа Github Actions к созданному хранилищу использовался Ngrok. Данный сервис позволяет пробрасывать порты между локальным окружением и сетью, предоставляя генерированный публичный адрес для доступа.

На начальном этапе настройки в отдельном окне терминала был установлен Ngrok с помощью `brew install ngrok`. Далее после регистрации на официальном сайте сервиса был получен токен доступа и проведена авторизация посредством выполения `ngrok config add-authtoken <personal_token>`. Затем был осуществлен проброс порта 8200, на котором запущен Vault, c помощью команды `ngrok http 8200`. Результат запуска Ngrok и выданный публичный адрес нашего хранилища изображены на рисунке ниже:

<img width="713" alt="Screenshot 2024-12-13 at 00 02 32" src="https://github.com/user-attachments/assets/bc8a3c83-8dc3-4af1-a4e2-843834470914" />

Далее полученный публичный адрес был скопирован. Затем в репозитории в разделе Settings → Secrets and variables → Actions был добавлен новый секрет `VAULT_ADDR` для доступа к хранилищу.

### Изменение скрипта
В уже разработанный в лабораторной работе №3 были внесены изменения, подразумевающие определение разрешений для работы с токенами и данными, установку Vault, конфигурирование OIDC, извлечение секретов из Vault и получение тестового запроса из базы данных, к которой мы подключаемся с помощью секретов. Добавленный участок кода скрипта приведен на рисунке ниже:

<img width="632" alt="Screenshot 2024-12-15 at 15 27 25" src="https://github.com/user-attachments/assets/1f6a377c-0408-4819-b4ca-fbd1d1c15874" />
<img width="632" alt="Screenshot 2024-12-15 at 15 35 40" src="https://github.com/user-attachments/assets/c1dd2ef1-291f-4dc5-8619-149885d83643" />

Разработанный код подразумевает сохранение всех секретов в переменных окружения через `>> $GITHUB_ENV`, что позволяет не светить в логах полученные секреты. Кроме того, все команды типа `echo` и `psql` не выводят значения секретов. Для адреса сервера Vault используется передача через GitHub Secrets, что также не светить секреты в логах, если использовать их в переменных окружения и не печатать в явном виде. Логируются только сообщения о выполнении определенных шагов.

## Результат
После внесения всех изменений и настройки всех элементов был выполнен тестовый запуск. Изменения были закоммичены и отправлены на удаленный репозиторий. Результат исполнения job, в которую были внесены изменения, приведен на рисунке ниже:

<img width="1499" alt="Screenshot 2024-12-13 at 00 02 12" src="https://github.com/user-attachments/assets/e9743e69-1415-49e7-9f92-92a8a5f72bf8" />

## Чем хорош выбранный способ?
Выбранный нами способ обладает следующими преимуществами:
* Обеспечение безопасности за счет использования временных токенов и строгих политик доступа с помощью OIDC;
* Автоматизированный процесс аутентификации и получения токенов, повышающий скорость выполнения и безопасность получения доступа к данным;
* Возможность конфигурации политик доступа для предоставления различных прав использования секретов на основе ролей;
* Использование Github Secrets для получения доступа к адресу хранилища секретов;
* Возможность масштабирования и внесения изменений в секреты, сроки их жизни и права доступа c помощью Hashicorp Vaulr;
* Сохранение секретов в переменных окружения для предотвращения раскрытия их в логах;
* Логирование сообщений исключительно о выполнении шагов по работе с секретами, а не о самих данных.

## Почему хранение секретов в CI/CD переменных репозитория не является хорошей практикой?
* Хранимые в переменных репозитория секреты могут быть раскрыты в логах в случае небезопасного использования в пайплайне команд вывода и возникновения ошибок, приводящих к попаданию секрета в публичные логи, при его выполнении;
* Невозможно централизованно управлять секретами и определять срок их жизни;
* Секреты могут быть получены сторонними сервисами, имеющими доступ к репозиторию;
* Понижена гибкость и усложнено управления системой получения секретов, так как при сохранении секретов в переменных репозитория использоваться они могут только внутри него.

## Выводы
По итогам выполнения лабораторной работы была реализована работа с секретами в рамках пайплайна с использованием хранилища Hashicorp Vault в интеграции с аутентификацией и получением доступа через OIDC и Github Secrets. Установлено, что выбранный способ использования секретов обладает преимуществами в обеспечении безопасности, возможностях управления и масштабировании. Определены причины, по которым хранение секретов в CI/CD переменных репозитория не является хорошей практикой.
